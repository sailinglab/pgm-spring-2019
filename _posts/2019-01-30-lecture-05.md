
---
layout: distill
title: "Lecture 5: Parameter Est. in fully observed BNs"
description: Introduction to the problem of Parameter Estimation in fully observed Bayesian Networks
date: 2019-02-10

lecturers:
  - name: Eric Xing
    url: "https://www.cs.cmu.edu/~epxing/"

authors:
  - name: Chentao Ye  # author's full name; let's order by sections
    url: "#"  # optional URL to the author's homepage
  - name: Muqiao Yang
    url: "#"
  - name: Qingtao Hu
    url: "#"
  - name: Sailun Xu
    url: "#"

editors:
  - name: Xun Zheng  # editor's full name
    url: "https://www.cs.cmu.edu/~xunzheng/"  # optional URL to the editor's homepage

abstract: >
  An example abstract block.
---

## Introduction


## Generalized Linear Models

Generalized linear model (GLM) is a flexible generalization of ordinary linear regression that allows the linear model to be related to response variables via a link function, that have error distribution models other than a normal distribution. For example both linear regression and logistic regression can be unified by generalized linear model.

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/GLM.png' | relative_url }}" />
    </div>
  </div>
  <figcaption>
    <strong>GLM</strong>
  </figcaption>
</figure>

### Commonality

$E_p(\mathbf{y)} = \mu = f(\theta^T\mathbf{x})$ 

where $f$ is the response function.

The observed input $\mathbf{x}$ is assumed to enter into the model via a linear combination of its elements, and the conditional mean $\mu$ is represented as a function $f(\xi)$ of $\xi$, where f is known as the link function of $\xi=\theta^T\mathbf{x}$. The observed output $\mathbf{y}$ is assumed to be characterized by an exponential family distribution with conditional mean $\mu$.

### MLE for GLIMs

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/responsFunc.png' | relative_url }}" />
    </div>
  </div>
  <figcaption>
    <strong>Example canonical response functions</strong>
  </figcaption>
</figure>

Log-likelihood $$\ell = \sum\limits_nlogh(y_n)+\sum\limits_n(\theta^Tx_ny_n-A(\eta_n))$$
Derivative is $$\frac{d\ell}{dt}=\sum_n(x_ny_n-\frac{dA(\eta_n)}{\eta_n}\frac{d\eta}{d\theta})=\sum_nx_n(y_n-\mu_n)=X^T(y-\mu)$$
which is a fixed point function since $\mu$ is a function of $\theta$.

 ### Iteratively Reweighted Least Squares (IRLS)

Recall that the Hessian matrix $H=-X^TWX$, and $\theta^*=(X^TX)^{-1}X^Ty$ in least mean square optimization, we use Newton-Raphson method with cost function $\ell$ $$\theta^{t+1}=\theta^t-H^{-1}\nabla_\theta\ell=(X^TW^tX)^{-1}X^TW^tz^t$$
where the response is $z^t=X\theta^t+(W^t)^{-1}(y-\mu^t)$. Hence, this can be understood as solving the Iteratively reweighted least squares problem
$$\theta^{t+1}=arg\min_\theta(z-X\theta)^T(z-X\theta)$$

## Global and local parameter independence

Simple graphical models can be viewed as building blocks of complex graphical models. With the same concept, if we assume the parameters for each local conditional probabilistic distribution to be globally independent, and all nodes are fully observed, then the log-likelihood function can be decomposed into a sum of local terms, one per node
$$\ell(\theta,D)=log p(D|\theta)=\sum_i(\sum_nlogp(x_{n,i}|\mathbf{x_{n,\pi_i},\theta_i}))$$

### Plate

A plate is a macro that allows subgraphs to be replicated. Conventionally, instead of drawing each repeated variable individually, a plate is used to group these variables into a subgraph that repeat together, and a number is drawn on the plate to represent the number of repetitions of the subgraph in the plate.

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/plate.png' | relative_url }}" />
    </div>
  </div>
</figure>

Rules for plates: Repeat every structure in a box a number of times given by the integer in the corner of the box (e.g. $N$), updating the plate index variable (e.g. $n$) as you go; Duplicate every arrow going into the plate and every arrow leaving the plate by connecting the arrows to each copy of the structure.

For example, in the directed acyclic network, it can be decomposed as 
$$p(x|\theta)=\sum_{i=1}^np(x_i|\mathbf{x}_{\pi_i})=p(x_1|\theta_1)p(x_2|x_1,\theta_2)p(x_3|x_1,\theta_3)p(x_4|x_2,x_3,\theta_4)$$

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/decompose.png' | relative_url }}" />
    </div>
  </div>
</figure>

Global parameter independence:
For every DAG model,  $p(\theta_m|G)=\sum_{i=1}\limits^Mp(\theta_i|G)$

Local parameter independence:
For every node, $p(\theta_i|G)=\sum\limits_{i=1}^{q_i}p(\theta_{x_i^k|\mathbf{x}_{\pi_i}^j}|G)$

### Global parameter sharing
Consider a network structure $G$ over a set of variables $X = \{X_1,...,X_n\}$, parameterized by a set of parameters $θ$. Each variable $X_i$ is associated with a CPD $P(X_i | U_i,\theta)$. Now, rather than assume that each such CPD has its own parameterization $\theta_{X_i|U_i}$, we assume that we have a certain set of shared parameters that are used by multiple variables in the network. That is the global parameter sharing. Assuming $\theta$ is partitioned into disjoint subsets $\theta_1,...,\theta_k$, and with each subset we assign a disjoint set of variables $\mathcal{V}_k\subset\mathcal{X}$. For $X_i\subset\mathcal{V_k}$, $$P(X_i|\mathbf{U}_i,\theta)=P(X_i|\mathbf{U}_i,\theta^k)$$
and for $X_i,X_j\subset\mathcal{V_k}$, $$P(X_i|\mathbf{U}_i,\theta^k)=P(X_j|\mathbf{U}_j,\theta^k)$$


## Supervised ML estimation
### Hidden Markov Model (HMM)
We are given a HMM, and let hidden states be $y_1, ..., y_N$, our observations be $x_1, ..., x_N$, which are all known to us.

In the training time, we can record the frequency of each transition from a hidden state to another, or from a hidden state to an observation state. 

Let $A_{ij}$ be a transition from a hidden state $i$ to a hidden state $j$, and let $B_{ik}$ be a transition from a hidden state $i$ to an observation state $k$. We calculate our parameters using maximum likelihood estimation by the following:


$$
a_{ij}^{ML} = \frac{\#transitions\ from\ i\ to\ j}{\#transitions\ from\ i\ to\ any\ hidden}
$$
$$
b_{ik}^{ML} = \frac{\#transitions\ from\ i\ to\ k}{\#transitions\ from\ i\ to\ any\ observation}
$$
If what we observe are continuous, we can treat them as Gaussian, and apply corresponding learning rules for Gaussian.

#### Pro
This method gives us the parameters that "best fit", or maximizes the likelihood of seeing the training data. Therefore for the test data, intuitively it should be at least close to the truth. MLE tends to give good performance in the reality.

#### Con
We just show that the parameters for calculation of probability upon seeing a test data depend on the frequency of seeing the same pattern in the training time. This leads to a problem. If there's a test data case that's never seen in the training data, then we will auto assign a zero probability to that test data, which is "infinitely wrong" because it will lead to a infinity cross entropy from real world to our model. 

This also shows the overfitting problem, that we fit our training data too well that we cannot generalize our model to the real world well.

#### Example on the slide
$b_{F4}=0$ because there's no casino roll such that $x=4$ and $y=F$ in the training data. However we all know this is not true!

### Pseudocounts
To solve this problem, we can add "hallucinated counts" to all the cases, so that even the cases which are never seen in the training time will get some counts. Therefore at test time there will be no zero probability assigned to any case.

#### How many Pseudocounts do we add
Imagine if the total frequency of the cases in training is 100, and we add 10000 counts to one case, then that case will be assigned a very high probability in the test time. What we just have done is equal to saying that "I strongly believe this will happen". In another word, we put lots of belief in that case.

However, if we just add one Pseudocount to each case, then the probability of frequent cases will decrease, but not too much. Their rankings in probability won't change, because it's just their denominators in MLE calculation have changed, by the same amount. The spared probability will be distributed to cases never seen in the training. They will be very small, but this eliminates the problem of zero probability in testing. This is what we call smoothing.

We can also see this as Bayesian Estimation under a uniform prior with "parameter strength", while we add pseudocounts to cases.

$$
m_i(y_1,...,y_{N_i}) = \sum_{x_i \in Val(X_i)} \prod_{j=1}^{k_i} m(x_i, y_{c_i})
$$

## Supplementary
### Density Estimation
Can be viewed as single-node graphical models
Instances of exponential family dist
Building blocks of general GM
MLE and Bayesian estimate

### Discrete Distributions
#### Bernoulli distribution: Ber($p$)
$P(x)=p^x(1-p)^{1-x}$
#### Multinomial distribution: Mult($1,\theta$)
It's generally similar to Binomial. However, the "1" in parameter indicates there will be only one trial. Therefore it's similar to Bernoulli, except now we have $k$ instances that could happen, each with a probability $\theta_i$, where $\sum_{i=1}^{k}{\theta_i}=1$.

$P(n)=\frac{N!}{n_1!n_2! ... n_k!}\theta^n$

### MLE: constrained optimization with Lagrange multipliers
#### Objective Function
$l(\theta;D)=\sum_k{n_klog\theta_k}$
#### constrain
$\sum_{k=1}^K{\theta_k=1}$
#### Constrained cost function with a Lagrange multiplier
$l^-=\sum_k{n_klog\theta_k+\lambda(1-\sum_{k=1}^K{\theta_k})}$

### Bayesian estimation
#### Dirichlet distribution
$P(\theta)=C(\alpha)\prod_k{\theta_k^{\alpha_k-1}}$
#### Posterior distribution of \theta
$P(\theta|x_1, ..., x_N)=\prod_k{\theta_k^{\alpha_k+n_k-1}}$
#### Posterior mean estimation
$\theta_k=\frac{n_k+\alpha_k}{N+|\alpha|}$
### Sequential Bayesian updating
#### Start with Dirichlet prior
$P(\bar{\theta}|\bar{\alpha})=Dir(\bar{\theta}:\bar{\alpha})$
#### Observe N' samples with sufficient statistics $\bar{n}'$. Posterior becomes
$P(\bar{\theta}|\bar{\alpha},\bar{n}')=Dir(\bar{\theta}:\bar{\alpha}+\bar{n}')$
### Hierarchical Bayesian Models
$\theta$ are the parameters for the likelihood $P(x|\theta)$

$\alpha$ are the parameters for the prior $P(\theta|\alpha)$

We can have hyper-parameters, etc.

We stop when the choice of hyper-parameters makes no difference to the marginal likelihood; typically make hyper-parameters constants.

### Limitation of Dirichlet Prior

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/Limitation_of_Dirichlet_Prior.png' | relative_url }}" />
    </div>
  </div>
</figure>

### The Logistic Normal Prior
Pro: co-variance structure
Con: non-conjugate

### Logistic Normal Densities

<figure>
  <div class="row">
    <div class="col two">
      <img src="{{ '/assets/img/notes/lecture-05/Logistic_Normal_Densities.png' | relative_url }}" />
    </div>
  </div>
</figure>

### Continuous Distributions
#### Uniform Probability Density Function
$P(x)=\frac{1}{b-a}$ for $a\leq x \leq b$
$P(x)=0$ elsewhere
#### Normal (Gaussian) Probability Density Function
$P(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$
#### Multivariate Gaussian
$P(X;\bar{\mu},\sum)=\frac{1}{(\sqrt{2\pi})^\frac{n}{2}|\sum|^{\frac{1}{2}}}exp(-\frac{1}{2}(X-\bar{\mu})^T\sum^{-1}(X-\bar{\mu}))$
Note that $X^TX=\sum_n{x_nx_n^T}$ may not be full rank (eg. if $N<D$), in which case $\sum_{ML}$ is not invertible
### Bayesian parameter estimation for a Gaussian
#### Reasons why we pursue a Bayesian approach
We would like to update our estimates sequentially over time.
We may have prior knowledge about the expected magnitude of the parameters.
The MLE for $\sum$ may not be full rank if we don’t have enough data.

#### Considering the following cases (in order of increasing complexity)
Known $\sigma$, unknown $\mu$
Known $\mu$, unknown $\sigma$
Unknown $\mu$ and $\sigma$